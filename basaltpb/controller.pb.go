// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: basaltpb/controller.proto

package basaltpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TODO(cockroachlabs/basalt#1): Simplify MountRequest to take a directory_id
// instead of cluster_id+store_id, deriving caller identity from the mTLS cert.
type MountRequest struct {
	// Identifier for this Pebble instance (e.g., node ID + store ID).
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// Zone of the mounting node.
	Zone string `protobuf:"bytes,2,opt,name=zone,proto3" json:"zone,omitempty"`
	// UUID of the CockroachDB cluster.
	ClusterId UUID `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3,customtype=UUID" json:"cluster_id"`
	// UUID of the store within the cluster.
	StoreId UUID `protobuf:"bytes,4,opt,name=store_id,json=storeId,proto3,customtype=UUID" json:"store_id"`
}

func (m *MountRequest) Reset()         { *m = MountRequest{} }
func (m *MountRequest) String() string { return proto.CompactTextString(m) }
func (*MountRequest) ProtoMessage()    {}
func (*MountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{0}
}
func (m *MountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountRequest.Merge(m, src)
}
func (m *MountRequest) XXX_Size() int {
	return m.Size()
}
func (m *MountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MountRequest proto.InternalMessageInfo

type MountResponse struct {
	// Unique mount ID for this session.
	MountId UUID `protobuf:"bytes,1,opt,name=mount_id,json=mountId,proto3,customtype=UUID" json:"mount_id"`
	// Root directory ID for the mounted store.
	DirectoryId UUID `protobuf:"bytes,2,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
	// Write token for authenticating with blob servers.
	WriteToken []byte `protobuf:"bytes,3,opt,name=write_token,json=writeToken,proto3" json:"write_token,omitempty"`
}

func (m *MountResponse) Reset()         { *m = MountResponse{} }
func (m *MountResponse) String() string { return proto.CompactTextString(m) }
func (*MountResponse) ProtoMessage()    {}
func (*MountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{1}
}
func (m *MountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountResponse.Merge(m, src)
}
func (m *MountResponse) XXX_Size() int {
	return m.Size()
}
func (m *MountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MountResponse proto.InternalMessageInfo

type UnmountRequest struct {
	MountId UUID `protobuf:"bytes,1,opt,name=mount_id,json=mountId,proto3,customtype=UUID" json:"mount_id"`
}

func (m *UnmountRequest) Reset()         { *m = UnmountRequest{} }
func (m *UnmountRequest) String() string { return proto.CompactTextString(m) }
func (*UnmountRequest) ProtoMessage()    {}
func (*UnmountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{2}
}
func (m *UnmountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnmountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnmountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnmountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnmountRequest.Merge(m, src)
}
func (m *UnmountRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnmountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnmountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnmountRequest proto.InternalMessageInfo

type UnmountResponse struct {
}

func (m *UnmountResponse) Reset()         { *m = UnmountResponse{} }
func (m *UnmountResponse) String() string { return proto.CompactTextString(m) }
func (*UnmountResponse) ProtoMessage()    {}
func (*UnmountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{3}
}
func (m *UnmountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnmountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnmountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnmountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnmountResponse.Merge(m, src)
}
func (m *UnmountResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnmountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnmountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnmountResponse proto.InternalMessageInfo

type CreateRequest struct {
	// Directory in which to create the file.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
	// Name for the new file.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Replication policy for the new file.
	Policy *ReplicationPolicy `protobuf:"bytes,3,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (m *CreateRequest) Reset()         { *m = CreateRequest{} }
func (m *CreateRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()    {}
func (*CreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{4}
}
func (m *CreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRequest.Merge(m, src)
}
func (m *CreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRequest proto.InternalMessageInfo

type CreateResponse struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (m *CreateResponse) Reset()         { *m = CreateResponse{} }
func (m *CreateResponse) String() string { return proto.CompactTextString(m) }
func (*CreateResponse) ProtoMessage()    {}
func (*CreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{5}
}
func (m *CreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateResponse.Merge(m, src)
}
func (m *CreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateResponse proto.InternalMessageInfo

type StatByPathRequest struct {
	// Directory containing the entry.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
	// Name of the entry to stat.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// If true, include all namespace references (hardlinks) in the response.
	IncludeReferences bool `protobuf:"varint,3,opt,name=include_references,json=includeReferences,proto3" json:"include_references,omitempty"`
}

func (m *StatByPathRequest) Reset()         { *m = StatByPathRequest{} }
func (m *StatByPathRequest) String() string { return proto.CompactTextString(m) }
func (*StatByPathRequest) ProtoMessage()    {}
func (*StatByPathRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{6}
}
func (m *StatByPathRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatByPathRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatByPathRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatByPathRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatByPathRequest.Merge(m, src)
}
func (m *StatByPathRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatByPathRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatByPathRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatByPathRequest proto.InternalMessageInfo

type StatByIDRequest struct {
	// Object ID to stat.
	ObjectId UUID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3,customtype=UUID" json:"object_id"`
	// If true, include all namespace references (hardlinks) in the response.
	IncludeReferences bool `protobuf:"varint,2,opt,name=include_references,json=includeReferences,proto3" json:"include_references,omitempty"`
	// If true, return the object even if it is a zombie (scheduled for deletion).
	IncludeZombies bool `protobuf:"varint,3,opt,name=include_zombies,json=includeZombies,proto3" json:"include_zombies,omitempty"`
}

func (m *StatByIDRequest) Reset()         { *m = StatByIDRequest{} }
func (m *StatByIDRequest) String() string { return proto.CompactTextString(m) }
func (*StatByIDRequest) ProtoMessage()    {}
func (*StatByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{7}
}
func (m *StatByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatByIDRequest.Merge(m, src)
}
func (m *StatByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatByIDRequest proto.InternalMessageInfo

type StatResponse struct {
	Meta *ObjectMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// Type of the entry (file or directory).
	Type EntryType `protobuf:"varint,2,opt,name=type,proto3,enum=basaltpb.EntryType" json:"type,omitempty"`
	// All namespace references (hardlinks) to this object.
	// Only populated when include_references is set in the request.
	References []Reference `protobuf:"bytes,3,rep,name=references,proto3" json:"references"`
	// True if the object is a zombie (scheduled for deletion).
	Zombie bool `protobuf:"varint,4,opt,name=zombie,proto3" json:"zombie,omitempty"`
}

func (m *StatResponse) Reset()         { *m = StatResponse{} }
func (m *StatResponse) String() string { return proto.CompactTextString(m) }
func (*StatResponse) ProtoMessage()    {}
func (*StatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{8}
}
func (m *StatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatResponse.Merge(m, src)
}
func (m *StatResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatResponse proto.InternalMessageInfo

type DeleteRequest struct {
	// Directory containing the entry to delete.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
	// Name of the entry to delete.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{9}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(m, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

type DeleteResponse struct {
	// Object ID that was unlinked (for files only).
	ObjectId UUID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3,customtype=UUID" json:"object_id"`
	// True if this was the last reference and the object will be deleted.
	ObjectDeleted bool `protobuf:"varint,2,opt,name=object_deleted,json=objectDeleted,proto3" json:"object_deleted,omitempty"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{10}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(m, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

type SealRequest struct {
	// Object to seal.
	ObjectId UUID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3,customtype=UUID" json:"object_id"`
	// Final size of the object.
	Size_ int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *SealRequest) Reset()         { *m = SealRequest{} }
func (m *SealRequest) String() string { return proto.CompactTextString(m) }
func (*SealRequest) ProtoMessage()    {}
func (*SealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{11}
}
func (m *SealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealRequest.Merge(m, src)
}
func (m *SealRequest) XXX_Size() int {
	return m.Size()
}
func (m *SealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SealRequest proto.InternalMessageInfo

type SealResponse struct {
}

func (m *SealResponse) Reset()         { *m = SealResponse{} }
func (m *SealResponse) String() string { return proto.CompactTextString(m) }
func (*SealResponse) ProtoMessage()    {}
func (*SealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{12}
}
func (m *SealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealResponse.Merge(m, src)
}
func (m *SealResponse) XXX_Size() int {
	return m.Size()
}
func (m *SealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SealResponse proto.InternalMessageInfo

type MkdirRequest struct {
	// Parent directory in which to create the subdirectory.
	ParentId UUID `protobuf:"bytes,1,opt,name=parent_id,json=parentId,proto3,customtype=UUID" json:"parent_id"`
	// Name for the new directory.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *MkdirRequest) Reset()         { *m = MkdirRequest{} }
func (m *MkdirRequest) String() string { return proto.CompactTextString(m) }
func (*MkdirRequest) ProtoMessage()    {}
func (*MkdirRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{13}
}
func (m *MkdirRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MkdirRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MkdirRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MkdirRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MkdirRequest.Merge(m, src)
}
func (m *MkdirRequest) XXX_Size() int {
	return m.Size()
}
func (m *MkdirRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MkdirRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MkdirRequest proto.InternalMessageInfo

type MkdirResponse struct {
	// ID of the newly created directory.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
}

func (m *MkdirResponse) Reset()         { *m = MkdirResponse{} }
func (m *MkdirResponse) String() string { return proto.CompactTextString(m) }
func (*MkdirResponse) ProtoMessage()    {}
func (*MkdirResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{14}
}
func (m *MkdirResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MkdirResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MkdirResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MkdirResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MkdirResponse.Merge(m, src)
}
func (m *MkdirResponse) XXX_Size() int {
	return m.Size()
}
func (m *MkdirResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MkdirResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MkdirResponse proto.InternalMessageInfo

type RmdirRequest struct {
	// Parent directory containing the directory to remove.
	ParentId UUID `protobuf:"bytes,1,opt,name=parent_id,json=parentId,proto3,customtype=UUID" json:"parent_id"`
	// Name of the directory to remove.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *RmdirRequest) Reset()         { *m = RmdirRequest{} }
func (m *RmdirRequest) String() string { return proto.CompactTextString(m) }
func (*RmdirRequest) ProtoMessage()    {}
func (*RmdirRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{15}
}
func (m *RmdirRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RmdirRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RmdirRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RmdirRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RmdirRequest.Merge(m, src)
}
func (m *RmdirRequest) XXX_Size() int {
	return m.Size()
}
func (m *RmdirRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RmdirRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RmdirRequest proto.InternalMessageInfo

type RmdirResponse struct {
}

func (m *RmdirResponse) Reset()         { *m = RmdirResponse{} }
func (m *RmdirResponse) String() string { return proto.CompactTextString(m) }
func (*RmdirResponse) ProtoMessage()    {}
func (*RmdirResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{16}
}
func (m *RmdirResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RmdirResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RmdirResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RmdirResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RmdirResponse.Merge(m, src)
}
func (m *RmdirResponse) XXX_Size() int {
	return m.Size()
}
func (m *RmdirResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RmdirResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RmdirResponse proto.InternalMessageInfo

type ListRequest struct {
	// Directory to list.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{17}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(m, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

type LinkRequest struct {
	// Directory in which to create the link.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
	// Name for the new link.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Existing object to link to.
	ObjectId UUID `protobuf:"bytes,3,opt,name=object_id,json=objectId,proto3,customtype=UUID" json:"object_id"`
}

func (m *LinkRequest) Reset()         { *m = LinkRequest{} }
func (m *LinkRequest) String() string { return proto.CompactTextString(m) }
func (*LinkRequest) ProtoMessage()    {}
func (*LinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{18}
}
func (m *LinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkRequest.Merge(m, src)
}
func (m *LinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *LinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LinkRequest proto.InternalMessageInfo

type LinkResponse struct {
}

func (m *LinkResponse) Reset()         { *m = LinkResponse{} }
func (m *LinkResponse) String() string { return proto.CompactTextString(m) }
func (*LinkResponse) ProtoMessage()    {}
func (*LinkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{19}
}
func (m *LinkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkResponse.Merge(m, src)
}
func (m *LinkResponse) XXX_Size() int {
	return m.Size()
}
func (m *LinkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LinkResponse proto.InternalMessageInfo

type RenameRequest struct {
	// Directory containing the entry to rename.
	DirectoryId UUID `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3,customtype=UUID" json:"directory_id"`
	// Current name of the entry.
	OldName string `protobuf:"bytes,2,opt,name=old_name,json=oldName,proto3" json:"old_name,omitempty"`
	// New name for the entry.
	NewName string `protobuf:"bytes,3,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
}

func (m *RenameRequest) Reset()         { *m = RenameRequest{} }
func (m *RenameRequest) String() string { return proto.CompactTextString(m) }
func (*RenameRequest) ProtoMessage()    {}
func (*RenameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{20}
}
func (m *RenameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameRequest.Merge(m, src)
}
func (m *RenameRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenameRequest proto.InternalMessageInfo

type RenameResponse struct {
}

func (m *RenameResponse) Reset()         { *m = RenameResponse{} }
func (m *RenameResponse) String() string { return proto.CompactTextString(m) }
func (*RenameResponse) ProtoMessage()    {}
func (*RenameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{21}
}
func (m *RenameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameResponse.Merge(m, src)
}
func (m *RenameResponse) XXX_Size() int {
	return m.Size()
}
func (m *RenameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RenameResponse proto.InternalMessageInfo

type HeartbeatBlobServerRequest struct {
	// UUID generated and persisted by the blob server.
	ServerId UUID `protobuf:"bytes,1,opt,name=server_id,json=serverId,proto3,customtype=UUID" json:"server_id"`
	// Addr (host:port) for the gRPC control endpoint.
	ControlAddr string `protobuf:"bytes,2,opt,name=control_addr,json=controlAddr,proto3" json:"control_addr,omitempty"`
	// Addr (host:port) for the data protocol.
	DataAddr string `protobuf:"bytes,3,opt,name=data_addr,json=dataAddr,proto3" json:"data_addr,omitempty"`
	// Zone of the blob server.
	Zone string `protobuf:"bytes,4,opt,name=zone,proto3" json:"zone,omitempty"`
	// Total storage capacity in bytes.
	CapacityBytes int64 `protobuf:"varint,5,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	// Currently used storage in bytes.
	UsedBytes int64 `protobuf:"varint,6,opt,name=used_bytes,json=usedBytes,proto3" json:"used_bytes,omitempty"`
}

func (m *HeartbeatBlobServerRequest) Reset()         { *m = HeartbeatBlobServerRequest{} }
func (m *HeartbeatBlobServerRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatBlobServerRequest) ProtoMessage()    {}
func (*HeartbeatBlobServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{22}
}
func (m *HeartbeatBlobServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatBlobServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatBlobServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatBlobServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatBlobServerRequest.Merge(m, src)
}
func (m *HeartbeatBlobServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatBlobServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatBlobServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatBlobServerRequest proto.InternalMessageInfo

type HeartbeatBlobServerResponse struct {
	// Integer ID assigned to this blob server, used in objects.replicas arrays.
	DiskId int32 `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
}

func (m *HeartbeatBlobServerResponse) Reset()         { *m = HeartbeatBlobServerResponse{} }
func (m *HeartbeatBlobServerResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatBlobServerResponse) ProtoMessage()    {}
func (*HeartbeatBlobServerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6a4f3446e7bd8, []int{23}
}
func (m *HeartbeatBlobServerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatBlobServerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatBlobServerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatBlobServerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatBlobServerResponse.Merge(m, src)
}
func (m *HeartbeatBlobServerResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatBlobServerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatBlobServerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatBlobServerResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MountRequest)(nil), "basaltpb.MountRequest")
	proto.RegisterType((*MountResponse)(nil), "basaltpb.MountResponse")
	proto.RegisterType((*UnmountRequest)(nil), "basaltpb.UnmountRequest")
	proto.RegisterType((*UnmountResponse)(nil), "basaltpb.UnmountResponse")
	proto.RegisterType((*CreateRequest)(nil), "basaltpb.CreateRequest")
	proto.RegisterType((*CreateResponse)(nil), "basaltpb.CreateResponse")
	proto.RegisterType((*StatByPathRequest)(nil), "basaltpb.StatByPathRequest")
	proto.RegisterType((*StatByIDRequest)(nil), "basaltpb.StatByIDRequest")
	proto.RegisterType((*StatResponse)(nil), "basaltpb.StatResponse")
	proto.RegisterType((*DeleteRequest)(nil), "basaltpb.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "basaltpb.DeleteResponse")
	proto.RegisterType((*SealRequest)(nil), "basaltpb.SealRequest")
	proto.RegisterType((*SealResponse)(nil), "basaltpb.SealResponse")
	proto.RegisterType((*MkdirRequest)(nil), "basaltpb.MkdirRequest")
	proto.RegisterType((*MkdirResponse)(nil), "basaltpb.MkdirResponse")
	proto.RegisterType((*RmdirRequest)(nil), "basaltpb.RmdirRequest")
	proto.RegisterType((*RmdirResponse)(nil), "basaltpb.RmdirResponse")
	proto.RegisterType((*ListRequest)(nil), "basaltpb.ListRequest")
	proto.RegisterType((*LinkRequest)(nil), "basaltpb.LinkRequest")
	proto.RegisterType((*LinkResponse)(nil), "basaltpb.LinkResponse")
	proto.RegisterType((*RenameRequest)(nil), "basaltpb.RenameRequest")
	proto.RegisterType((*RenameResponse)(nil), "basaltpb.RenameResponse")
	proto.RegisterType((*HeartbeatBlobServerRequest)(nil), "basaltpb.HeartbeatBlobServerRequest")
	proto.RegisterType((*HeartbeatBlobServerResponse)(nil), "basaltpb.HeartbeatBlobServerResponse")
}

func init() { proto.RegisterFile("basaltpb/controller.proto", fileDescriptor_6ae6a4f3446e7bd8) }

var fileDescriptor_6ae6a4f3446e7bd8 = []byte{
	// 1098 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x4f, 0x1b, 0x47,
	0x14, 0x67, 0x61, 0x31, 0xe6, 0xf9, 0x0f, 0x65, 0x92, 0x10, 0x30, 0xaa, 0x49, 0x57, 0x45, 0x50,
	0xb5, 0xc5, 0x15, 0x51, 0xab, 0xd0, 0xa8, 0x51, 0xe3, 0x50, 0xa9, 0x5b, 0x85, 0x36, 0x5a, 0xe0,
	0x92, 0x8b, 0x35, 0xbb, 0x33, 0x85, 0x2d, 0xeb, 0x1d, 0x77, 0x77, 0x1c, 0x64, 0xa4, 0x9e, 0xab,
	0xf6, 0xd4, 0x43, 0x2f, 0xfd, 0x1e, 0xfd, 0x00, 0x3d, 0x72, 0xcc, 0xb1, 0xea, 0x21, 0x6a, 0xe0,
	0x8b, 0x54, 0xf3, 0x67, 0xd7, 0xb3, 0x60, 0x37, 0x01, 0x71, 0x1b, 0xbf, 0xbf, 0xbf, 0xf7, 0xde,
	0xcc, 0xef, 0xad, 0x61, 0xc9, 0xc7, 0x29, 0x8e, 0x78, 0xcf, 0x6f, 0x05, 0x2c, 0xe6, 0x09, 0x8b,
	0x22, 0x9a, 0x6c, 0xf4, 0x12, 0xc6, 0x19, 0x2a, 0x67, 0xaa, 0xc6, 0x1d, 0xc3, 0xa8, 0xdb, 0x65,
	0xb1, 0x32, 0x68, 0xdc, 0x3e, 0x60, 0x07, 0x4c, 0x1e, 0x5b, 0xe2, 0xa4, 0xa4, 0xce, 0x1f, 0x16,
	0x54, 0x77, 0x58, 0x3f, 0xe6, 0x1e, 0xfd, 0xb1, 0x4f, 0x53, 0x8e, 0x56, 0xa0, 0x12, 0xc6, 0x29,
	0xc7, 0x71, 0x40, 0x3b, 0x21, 0x59, 0xb4, 0xee, 0x59, 0xeb, 0xb3, 0x1e, 0x64, 0x22, 0x97, 0x20,
	0x04, 0xf6, 0x09, 0x8b, 0xe9, 0xe2, 0xa4, 0xd4, 0xc8, 0x33, 0xfa, 0x10, 0x20, 0x88, 0xfa, 0x29,
	0xa7, 0x89, 0xf0, 0x99, 0xba, 0x67, 0xad, 0x57, 0xdb, 0xd5, 0xd3, 0x57, 0x2b, 0x13, 0xff, 0xbc,
	0x5a, 0xb1, 0xf7, 0xf7, 0xdd, 0x6d, 0x6f, 0x56, 0xeb, 0x5d, 0x82, 0xd6, 0xa0, 0x9c, 0x72, 0x96,
	0xc8, 0xf0, 0xf6, 0x08, 0xd3, 0x19, 0xa9, 0x75, 0x89, 0xf3, 0xab, 0x05, 0x35, 0x8d, 0x2d, 0xed,
	0xb1, 0x38, 0xa5, 0xc2, 0xb5, 0x2b, 0x04, 0x19, 0xb2, 0x4b, 0xae, 0x52, 0xeb, 0x12, 0xd4, 0x82,
	0x2a, 0x09, 0x13, 0x1a, 0x70, 0x96, 0x0c, 0x84, 0xf1, 0xe4, 0x08, 0xe3, 0x4a, 0x6e, 0xe1, 0x12,
	0x51, 0xf6, 0x71, 0x12, 0x72, 0xda, 0xe1, 0xec, 0x88, 0xc6, 0xaa, 0x04, 0x0f, 0xa4, 0x68, 0x4f,
	0x48, 0x9c, 0x2d, 0xa8, 0xef, 0xc7, 0x5d, 0xb3, 0x53, 0x6f, 0x0b, 0xc6, 0x99, 0x87, 0xb9, 0xdc,
	0x55, 0x15, 0xe2, 0xfc, 0x62, 0x41, 0xed, 0x49, 0x42, 0x31, 0xa7, 0x59, 0xb4, 0x8b, 0x88, 0xad,
	0x37, 0x21, 0x46, 0x60, 0xc7, 0xb8, 0x9b, 0xcf, 0x41, 0x9c, 0xd1, 0x7d, 0x28, 0xf5, 0x58, 0x14,
	0x06, 0x03, 0x59, 0x40, 0x65, 0x73, 0x79, 0x23, 0xbb, 0x0b, 0x1b, 0x1e, 0xed, 0x45, 0x61, 0x80,
	0x79, 0xc8, 0xe2, 0x67, 0xd2, 0xc4, 0xd3, 0xa6, 0xce, 0xe7, 0x50, 0xcf, 0xa0, 0xe8, 0x36, 0xaf,
	0x83, 0xdd, 0xa5, 0x1c, 0x4b, 0x0c, 0x95, 0xcd, 0xdb, 0xc3, 0x20, 0xdf, 0xf9, 0x3f, 0xd0, 0x80,
	0xef, 0x50, 0x8e, 0x3d, 0x69, 0xe1, 0xfc, 0x6c, 0xc1, 0xfc, 0x2e, 0xc7, 0xbc, 0x3d, 0x78, 0x86,
	0xf9, 0xe1, 0x8d, 0xd6, 0xf2, 0x31, 0xa0, 0x30, 0x0e, 0xa2, 0x3e, 0xa1, 0x9d, 0x84, 0x7e, 0x4f,
	0x13, 0x1a, 0x07, 0x34, 0x95, 0x75, 0x95, 0xbd, 0x79, 0xad, 0xf1, 0x72, 0x85, 0xf3, 0xbb, 0x05,
	0x73, 0x0a, 0x89, 0xbb, 0x9d, 0xe1, 0xf8, 0x00, 0x66, 0x99, 0x44, 0x3c, 0x0e, 0x44, 0x59, 0xa9,
	0x5d, 0x32, 0x26, 0xdb, 0xe4, 0x98, 0x6c, 0x68, 0x0d, 0xe6, 0x32, 0xf3, 0x13, 0xd6, 0xf5, 0xc3,
	0x1c, 0x59, 0x5d, 0x8b, 0x9f, 0x2b, 0xa9, 0xf3, 0xa7, 0x05, 0x55, 0x01, 0xeb, 0xea, 0xbd, 0x45,
	0x6b, 0x60, 0xf3, 0x41, 0x4f, 0x35, 0xa5, 0xbe, 0x79, 0x6b, 0x68, 0xf9, 0x55, 0xcc, 0x93, 0xc1,
	0xde, 0xa0, 0x47, 0x3d, 0x69, 0x80, 0xb6, 0x00, 0x0a, 0x1d, 0x9a, 0x5a, 0xaf, 0x98, 0xe6, 0x39,
	0xec, 0xb6, 0x2d, 0x8a, 0xf7, 0x0c, 0x63, 0xb4, 0x00, 0x25, 0x85, 0x5f, 0xbe, 0xc4, 0xb2, 0xa7,
	0x7f, 0x39, 0x7b, 0x50, 0xdb, 0xa6, 0x11, 0xbd, 0xd9, 0xeb, 0xe9, 0xf8, 0x50, 0xcf, 0xa2, 0xea,
	0x6e, 0x5c, 0x61, 0x42, 0xab, 0x50, 0xd7, 0xa6, 0x44, 0xc6, 0x20, 0x7a, 0x3a, 0x35, 0x25, 0x55,
	0x81, 0x89, 0xf3, 0x14, 0x2a, 0xbb, 0x14, 0x47, 0xd7, 0xb8, 0x02, 0x08, 0xec, 0x34, 0x3c, 0x51,
	0x88, 0xa7, 0x3c, 0x79, 0x76, 0xea, 0x50, 0x55, 0xd1, 0xf4, 0xbb, 0xdd, 0x81, 0xea, 0xce, 0x11,
	0x09, 0x13, 0x23, 0x7c, 0x0f, 0x27, 0x74, 0x3c, 0x09, 0x94, 0x95, 0x7a, 0x4c, 0x43, 0xbe, 0x84,
	0x9a, 0x0e, 0xa7, 0xfb, 0x71, 0xd5, 0x36, 0x0b, 0x40, 0x5e, 0xf7, 0xe6, 0x00, 0xcd, 0x41, 0x4d,
	0x87, 0xd3, 0x05, 0x3f, 0x82, 0xca, 0xd3, 0x30, 0xe5, 0xd7, 0xbd, 0x06, 0xce, 0x4f, 0xc2, 0x3f,
	0x3e, 0xba, 0x51, 0x66, 0x28, 0xcc, 0x74, 0xea, 0xff, 0x66, 0x2a, 0xe6, 0xa7, 0xd2, 0xeb, 0x72,
	0x5e, 0x40, 0xcd, 0xa3, 0x22, 0xc8, 0xb5, 0x01, 0x2d, 0x41, 0x99, 0x45, 0xa4, 0x63, 0x80, 0x9a,
	0x61, 0x11, 0xf9, 0x56, 0xe0, 0x5a, 0x82, 0x72, 0x4c, 0x8f, 0x95, 0x6a, 0x4a, 0xa9, 0x62, 0x7a,
	0x2c, 0x54, 0xce, 0x3b, 0x50, 0xcf, 0xf2, 0x6a, 0x24, 0xaf, 0x2d, 0x68, 0x7c, 0x4d, 0x71, 0xc2,
	0x7d, 0x8a, 0x79, 0x3b, 0x62, 0xfe, 0x2e, 0x4d, 0x5e, 0x50, 0x73, 0x8e, 0xa9, 0x14, 0x8c, 0x9d,
	0xa3, 0x52, 0xbb, 0x04, 0xbd, 0x07, 0x55, 0xfd, 0x35, 0xd0, 0xc1, 0x84, 0x24, 0x1a, 0x55, 0x45,
	0xcb, 0x1e, 0x13, 0x92, 0xa0, 0x65, 0x98, 0x25, 0x98, 0x63, 0xa5, 0x57, 0xd0, 0xca, 0x42, 0x20,
	0x95, 0xd9, 0x42, 0xb7, 0x8d, 0x85, 0xbe, 0x0a, 0xf5, 0x00, 0xf7, 0x70, 0x10, 0xf2, 0x41, 0xc7,
	0x1f, 0x70, 0x9a, 0x2e, 0x4e, 0xcb, 0x57, 0x51, 0xcb, 0xa4, 0x6d, 0x21, 0x44, 0xef, 0x02, 0xf4,
	0x53, 0x4a, 0xb4, 0x49, 0x49, 0x9a, 0xcc, 0x0a, 0x89, 0x54, 0x3b, 0x9f, 0xc1, 0xf2, 0xc8, 0x12,
	0xf5, 0x65, 0xbf, 0x0b, 0x33, 0x24, 0x4c, 0x8f, 0xb2, 0x0a, 0xa7, 0xbd, 0x92, 0xf8, 0xe9, 0x92,
	0xcd, 0xbf, 0x4a, 0x00, 0x4f, 0xf2, 0x0f, 0x1c, 0xf4, 0x00, 0xa6, 0xe5, 0x67, 0x00, 0x5a, 0x18,
	0x92, 0x9a, 0xf9, 0xcd, 0xd2, 0xb8, 0x7b, 0x49, 0xae, 0x33, 0x3c, 0x82, 0x19, 0xbd, 0x79, 0xd1,
	0xe2, 0xd0, 0xa6, 0xb8, 0xc7, 0x1b, 0x4b, 0x23, 0x34, 0xda, 0xff, 0x21, 0x94, 0xd4, 0x6a, 0x44,
	0x46, 0x8a, 0xc2, 0xde, 0x6e, 0x2c, 0x5e, 0x56, 0x68, 0xe7, 0xc7, 0x00, 0xc3, 0xd5, 0x88, 0x8c,
	0x55, 0x7c, 0x69, 0x61, 0x36, 0x16, 0x8a, 0xca, 0x3c, 0xc4, 0x17, 0x50, 0xce, 0x76, 0x1a, 0x5a,
	0xba, 0x18, 0x20, 0xdf, 0x73, 0x63, 0xdd, 0x1f, 0x42, 0x49, 0xd1, 0xa2, 0x09, 0xbf, 0xc0, 0xeb,
	0x26, 0xfc, 0x0b, 0xd4, 0xfc, 0x29, 0xd8, 0x82, 0xfa, 0xd0, 0x1d, 0x23, 0xf8, 0x90, 0x58, 0x0b,
	0x39, 0x0d, 0x86, 0x94, 0xc3, 0x12, 0x94, 0x56, 0x18, 0x96, 0x41, 0x99, 0x85, 0x61, 0x15, 0xb8,
	0xef, 0x01, 0x4c, 0x4b, 0xee, 0x31, 0x3d, 0x4d, 0x6e, 0x33, 0x3d, 0x0b, 0x24, 0x85, 0xb6, 0xc0,
	0x16, 0x24, 0x65, 0x42, 0x35, 0x48, 0xab, 0x50, 0x63, 0xf6, 0x92, 0xe5, 0x0e, 0xfd, 0xc4, 0x12,
	0x55, 0x0a, 0x82, 0x28, 0xba, 0xe6, 0x7c, 0x65, 0x56, 0x69, 0xf2, 0x88, 0xe8, 0xac, 0x7a, 0xcf,
	0x66, 0x67, 0x0b, 0xcc, 0x62, 0x66, 0x2d, 0x3e, 0x7d, 0xe4, 0xc3, 0xad, 0x11, 0xcf, 0x02, 0xbd,
	0x3f, 0x74, 0x18, 0x4f, 0x0c, 0x8d, 0xd5, 0x37, 0x58, 0xa9, 0x1c, 0xed, 0x6f, 0x4e, 0x5f, 0x37,
	0x27, 0x4e, 0xcf, 0x9a, 0xd6, 0xcb, 0xb3, 0xa6, 0xf5, 0xef, 0x59, 0xd3, 0xfa, 0xed, 0xbc, 0x39,
	0xf1, 0xf2, 0xbc, 0x39, 0xf1, 0xf7, 0x79, 0x73, 0xe2, 0xf9, 0x47, 0x07, 0x21, 0x3f, 0xec, 0xfb,
	0x1b, 0x01, 0xeb, 0xb6, 0x02, 0x16, 0x1c, 0x25, 0x0c, 0x07, 0x87, 0xc4, 0x6f, 0xa9, 0xd0, 0x41,
	0x14, 0xd2, 0x98, 0xb7, 0xb2, 0x3c, 0x7e, 0x49, 0xfe, 0x55, 0xb8, 0xff, 0x5f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xa0, 0x6f, 0x92, 0x1f, 0x7e, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ControllerClient is the client API for Controller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ControllerClient interface {
	// Mount registers a Pebble instance and acquires exclusive write access
	// to its store directory. Returns the mount ID and directory ID.
	Mount(ctx context.Context, in *MountRequest, opts ...grpc.CallOption) (*MountResponse, error)
	// Unmount releases the write lock on a store directory.
	Unmount(ctx context.Context, in *UnmountRequest, opts ...grpc.CallOption) (*UnmountResponse, error)
	// Create allocates a new file in a directory and selects replicas.
	// Requires the caller to hold a mount for the directory, or the directory
	// must not be mounted by anyone.
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	// StatByPath returns metadata for an entry by (directory_id, name).
	// Does not require a mount.
	StatByPath(ctx context.Context, in *StatByPathRequest, opts ...grpc.CallOption) (*StatResponse, error)
	// StatByID returns metadata for an object by ID.
	// Does not require a mount.
	StatByID(ctx context.Context, in *StatByIDRequest, opts ...grpc.CallOption) (*StatResponse, error)
	// Delete removes an entry from a directory. If this was the last reference
	// to the object, the object and its replicas are scheduled for deletion.
	// Requires mount or unmounted directory.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Seal marks an object as immutable with its final size.
	// Requires mount or unmounted directory.
	Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error)
	// Mkdir creates a subdirectory within a directory.
	// Requires mount or unmounted directory.
	Mkdir(ctx context.Context, in *MkdirRequest, opts ...grpc.CallOption) (*MkdirResponse, error)
	// Rmdir removes an empty directory.
	// Requires mount or unmounted directory.
	Rmdir(ctx context.Context, in *RmdirRequest, opts ...grpc.CallOption) (*RmdirResponse, error)
	// List returns all entries in a directory as a stream.
	// Does not require a mount.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (Controller_ListClient, error)
	// Link creates a hardlink to an existing object in a directory.
	// Requires mount or unmounted directory.
	Link(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*LinkResponse, error)
	// Rename moves an entry within the same directory.
	// Requires mount or unmounted directory.
	Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error)
	// HeartbeatBlobServer registers a blob server with the controller.
	// Uses UPSERT semantics: handles initial registration, heartbeats, and
	// capacity updates. Blob servers should call this periodically to maintain
	// liveness.
	HeartbeatBlobServer(ctx context.Context, in *HeartbeatBlobServerRequest, opts ...grpc.CallOption) (*HeartbeatBlobServerResponse, error)
}

type controllerClient struct {
	cc *grpc.ClientConn
}

func NewControllerClient(cc *grpc.ClientConn) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) Mount(ctx context.Context, in *MountRequest, opts ...grpc.CallOption) (*MountResponse, error) {
	out := new(MountResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Mount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Unmount(ctx context.Context, in *UnmountRequest, opts ...grpc.CallOption) (*UnmountResponse, error) {
	out := new(UnmountResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Unmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) StatByPath(ctx context.Context, in *StatByPathRequest, opts ...grpc.CallOption) (*StatResponse, error) {
	out := new(StatResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/StatByPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) StatByID(ctx context.Context, in *StatByIDRequest, opts ...grpc.CallOption) (*StatResponse, error) {
	out := new(StatResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/StatByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error) {
	out := new(SealResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Mkdir(ctx context.Context, in *MkdirRequest, opts ...grpc.CallOption) (*MkdirResponse, error) {
	out := new(MkdirResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Mkdir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Rmdir(ctx context.Context, in *RmdirRequest, opts ...grpc.CallOption) (*RmdirResponse, error) {
	out := new(RmdirResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Rmdir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (Controller_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Controller_serviceDesc.Streams[0], "/basaltpb.Controller/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &controllerListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Controller_ListClient interface {
	Recv() (*DirectoryEntry, error)
	grpc.ClientStream
}

type controllerListClient struct {
	grpc.ClientStream
}

func (x *controllerListClient) Recv() (*DirectoryEntry, error) {
	m := new(DirectoryEntry)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controllerClient) Link(ctx context.Context, in *LinkRequest, opts ...grpc.CallOption) (*LinkResponse, error) {
	out := new(LinkResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Link", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error) {
	out := new(RenameResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/Rename", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) HeartbeatBlobServer(ctx context.Context, in *HeartbeatBlobServerRequest, opts ...grpc.CallOption) (*HeartbeatBlobServerResponse, error) {
	out := new(HeartbeatBlobServerResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Controller/HeartbeatBlobServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerServer is the server API for Controller service.
type ControllerServer interface {
	// Mount registers a Pebble instance and acquires exclusive write access
	// to its store directory. Returns the mount ID and directory ID.
	Mount(context.Context, *MountRequest) (*MountResponse, error)
	// Unmount releases the write lock on a store directory.
	Unmount(context.Context, *UnmountRequest) (*UnmountResponse, error)
	// Create allocates a new file in a directory and selects replicas.
	// Requires the caller to hold a mount for the directory, or the directory
	// must not be mounted by anyone.
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	// StatByPath returns metadata for an entry by (directory_id, name).
	// Does not require a mount.
	StatByPath(context.Context, *StatByPathRequest) (*StatResponse, error)
	// StatByID returns metadata for an object by ID.
	// Does not require a mount.
	StatByID(context.Context, *StatByIDRequest) (*StatResponse, error)
	// Delete removes an entry from a directory. If this was the last reference
	// to the object, the object and its replicas are scheduled for deletion.
	// Requires mount or unmounted directory.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Seal marks an object as immutable with its final size.
	// Requires mount or unmounted directory.
	Seal(context.Context, *SealRequest) (*SealResponse, error)
	// Mkdir creates a subdirectory within a directory.
	// Requires mount or unmounted directory.
	Mkdir(context.Context, *MkdirRequest) (*MkdirResponse, error)
	// Rmdir removes an empty directory.
	// Requires mount or unmounted directory.
	Rmdir(context.Context, *RmdirRequest) (*RmdirResponse, error)
	// List returns all entries in a directory as a stream.
	// Does not require a mount.
	List(*ListRequest, Controller_ListServer) error
	// Link creates a hardlink to an existing object in a directory.
	// Requires mount or unmounted directory.
	Link(context.Context, *LinkRequest) (*LinkResponse, error)
	// Rename moves an entry within the same directory.
	// Requires mount or unmounted directory.
	Rename(context.Context, *RenameRequest) (*RenameResponse, error)
	// HeartbeatBlobServer registers a blob server with the controller.
	// Uses UPSERT semantics: handles initial registration, heartbeats, and
	// capacity updates. Blob servers should call this periodically to maintain
	// liveness.
	HeartbeatBlobServer(context.Context, *HeartbeatBlobServerRequest) (*HeartbeatBlobServerResponse, error)
}

// UnimplementedControllerServer can be embedded to have forward compatible implementations.
type UnimplementedControllerServer struct {
}

func (*UnimplementedControllerServer) Mount(ctx context.Context, req *MountRequest) (*MountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mount not implemented")
}
func (*UnimplementedControllerServer) Unmount(ctx context.Context, req *UnmountRequest) (*UnmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unmount not implemented")
}
func (*UnimplementedControllerServer) Create(ctx context.Context, req *CreateRequest) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedControllerServer) StatByPath(ctx context.Context, req *StatByPathRequest) (*StatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatByPath not implemented")
}
func (*UnimplementedControllerServer) StatByID(ctx context.Context, req *StatByIDRequest) (*StatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatByID not implemented")
}
func (*UnimplementedControllerServer) Delete(ctx context.Context, req *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedControllerServer) Seal(ctx context.Context, req *SealRequest) (*SealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (*UnimplementedControllerServer) Mkdir(ctx context.Context, req *MkdirRequest) (*MkdirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mkdir not implemented")
}
func (*UnimplementedControllerServer) Rmdir(ctx context.Context, req *RmdirRequest) (*RmdirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rmdir not implemented")
}
func (*UnimplementedControllerServer) List(req *ListRequest, srv Controller_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedControllerServer) Link(ctx context.Context, req *LinkRequest) (*LinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Link not implemented")
}
func (*UnimplementedControllerServer) Rename(ctx context.Context, req *RenameRequest) (*RenameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rename not implemented")
}
func (*UnimplementedControllerServer) HeartbeatBlobServer(ctx context.Context, req *HeartbeatBlobServerRequest) (*HeartbeatBlobServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeartbeatBlobServer not implemented")
}

func RegisterControllerServer(s *grpc.Server, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_Mount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Mount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Mount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Mount(ctx, req.(*MountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Unmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Unmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Unmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Unmount(ctx, req.(*UnmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_StatByPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatByPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).StatByPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/StatByPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).StatByPath(ctx, req.(*StatByPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_StatByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).StatByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/StatByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).StatByID(ctx, req.(*StatByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Seal(ctx, req.(*SealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Mkdir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MkdirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Mkdir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Mkdir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Mkdir(ctx, req.(*MkdirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Rmdir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RmdirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Rmdir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Rmdir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Rmdir(ctx, req.(*RmdirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControllerServer).List(m, &controllerListServer{stream})
}

type Controller_ListServer interface {
	Send(*DirectoryEntry) error
	grpc.ServerStream
}

type controllerListServer struct {
	grpc.ServerStream
}

func (x *controllerListServer) Send(m *DirectoryEntry) error {
	return x.ServerStream.SendMsg(m)
}

func _Controller_Link_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Link(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Link",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Link(ctx, req.(*LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_Rename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Rename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/Rename",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Rename(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_HeartbeatBlobServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatBlobServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).HeartbeatBlobServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Controller/HeartbeatBlobServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).HeartbeatBlobServer(ctx, req.(*HeartbeatBlobServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "basaltpb.Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mount",
			Handler:    _Controller_Mount_Handler,
		},
		{
			MethodName: "Unmount",
			Handler:    _Controller_Unmount_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Controller_Create_Handler,
		},
		{
			MethodName: "StatByPath",
			Handler:    _Controller_StatByPath_Handler,
		},
		{
			MethodName: "StatByID",
			Handler:    _Controller_StatByID_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Controller_Delete_Handler,
		},
		{
			MethodName: "Seal",
			Handler:    _Controller_Seal_Handler,
		},
		{
			MethodName: "Mkdir",
			Handler:    _Controller_Mkdir_Handler,
		},
		{
			MethodName: "Rmdir",
			Handler:    _Controller_Rmdir_Handler,
		},
		{
			MethodName: "Link",
			Handler:    _Controller_Link_Handler,
		},
		{
			MethodName: "Rename",
			Handler:    _Controller_Rename_Handler,
		},
		{
			MethodName: "HeartbeatBlobServer",
			Handler:    _Controller_HeartbeatBlobServer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _Controller_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "basaltpb/controller.proto",
}

func (m *MountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ClusterId.Size()
		i -= size
		if _, err := m.ClusterId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintController(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InstanceId) > 0 {
		i -= len(m.InstanceId)
		copy(dAtA[i:], m.InstanceId)
		i = encodeVarintController(dAtA, i, uint64(len(m.InstanceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WriteToken) > 0 {
		i -= len(m.WriteToken)
		copy(dAtA[i:], m.WriteToken)
		i = encodeVarintController(dAtA, i, uint64(len(m.WriteToken)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.MountId.Size()
		i -= size
		if _, err := m.MountId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnmountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnmountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnmountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MountId.Size()
		i -= size
		if _, err := m.MountId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnmountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnmountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnmountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintController(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintController(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintController(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatByPathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatByPathRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatByPathRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeReferences {
		i--
		if m.IncludeReferences {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintController(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StatByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeZombies {
		i--
		if m.IncludeZombies {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IncludeReferences {
		i--
		if m.IncludeReferences {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Zombie {
		i--
		if m.Zombie {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.References) > 0 {
		for iNdEx := len(m.References) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.References[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintController(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintController(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintController(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintController(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ObjectDeleted {
		i--
		if m.ObjectDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SealRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintController(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MkdirRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MkdirRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MkdirRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintController(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ParentId.Size()
		i -= size
		if _, err := m.ParentId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MkdirResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MkdirResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MkdirResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RmdirRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmdirRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RmdirRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintController(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ParentId.Size()
		i -= size
		if _, err := m.ParentId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RmdirResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmdirResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RmdirResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintController(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LinkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RenameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewName) > 0 {
		i -= len(m.NewName)
		copy(dAtA[i:], m.NewName)
		i = encodeVarintController(dAtA, i, uint64(len(m.NewName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OldName) > 0 {
		i -= len(m.OldName)
		copy(dAtA[i:], m.OldName)
		i = encodeVarintController(dAtA, i, uint64(len(m.OldName)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.DirectoryId.Size()
		i -= size
		if _, err := m.DirectoryId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RenameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *HeartbeatBlobServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatBlobServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatBlobServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsedBytes != 0 {
		i = encodeVarintController(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.CapacityBytes != 0 {
		i = encodeVarintController(dAtA, i, uint64(m.CapacityBytes))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintController(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DataAddr) > 0 {
		i -= len(m.DataAddr)
		copy(dAtA[i:], m.DataAddr)
		i = encodeVarintController(dAtA, i, uint64(len(m.DataAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ControlAddr) > 0 {
		i -= len(m.ControlAddr)
		copy(dAtA[i:], m.ControlAddr)
		i = encodeVarintController(dAtA, i, uint64(len(m.ControlAddr)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.ServerId.Size()
		i -= size
		if _, err := m.ServerId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintController(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HeartbeatBlobServerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatBlobServerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatBlobServerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiskId != 0 {
		i = encodeVarintController(dAtA, i, uint64(m.DiskId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintController(dAtA []byte, offset int, v uint64) int {
	offset -= sovController(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	l = m.ClusterId.Size()
	n += 1 + l + sovController(uint64(l))
	l = m.StoreId.Size()
	n += 1 + l + sovController(uint64(l))
	return n
}

func (m *MountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MountId.Size()
	n += 1 + l + sovController(uint64(l))
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.WriteToken)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *UnmountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MountId.Size()
	n += 1 + l + sovController(uint64(l))
	return n
}

func (m *UnmountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *CreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *StatByPathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	if m.IncludeReferences {
		n += 2
	}
	return n
}

func (m *StatByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectId.Size()
	n += 1 + l + sovController(uint64(l))
	if m.IncludeReferences {
		n += 2
	}
	if m.IncludeZombies {
		n += 2
	}
	return n
}

func (m *StatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovController(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovController(uint64(m.Type))
	}
	if len(m.References) > 0 {
		for _, e := range m.References {
			l = e.Size()
			n += 1 + l + sovController(uint64(l))
		}
	}
	if m.Zombie {
		n += 2
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectId.Size()
	n += 1 + l + sovController(uint64(l))
	if m.ObjectDeleted {
		n += 2
	}
	return n
}

func (m *SealRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectId.Size()
	n += 1 + l + sovController(uint64(l))
	if m.Size_ != 0 {
		n += 1 + sovController(uint64(m.Size_))
	}
	return n
}

func (m *SealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MkdirRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ParentId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *MkdirResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	return n
}

func (m *RmdirRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ParentId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *RmdirResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	return n
}

func (m *LinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	l = m.ObjectId.Size()
	n += 1 + l + sovController(uint64(l))
	return n
}

func (m *LinkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RenameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DirectoryId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.OldName)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	l = len(m.NewName)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	return n
}

func (m *RenameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *HeartbeatBlobServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ServerId.Size()
	n += 1 + l + sovController(uint64(l))
	l = len(m.ControlAddr)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	l = len(m.DataAddr)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovController(uint64(l))
	}
	if m.CapacityBytes != 0 {
		n += 1 + sovController(uint64(m.CapacityBytes))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovController(uint64(m.UsedBytes))
	}
	return n
}

func (m *HeartbeatBlobServerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskId != 0 {
		n += 1 + sovController(uint64(m.DiskId))
	}
	return n
}

func sovController(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozController(x uint64) (n int) {
	return sovController(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteToken = append(m.WriteToken[:0], dAtA[iNdEx:postIndex]...)
			if m.WriteToken == nil {
				m.WriteToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnmountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnmountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnmountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnmountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnmountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnmountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &ReplicationPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatByPathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatByPathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatByPathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeReferences", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeReferences = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeReferences", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeReferences = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeZombies", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeZombies = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EntryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, Reference{})
			if err := m.References[len(m.References)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zombie", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Zombie = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ObjectDeleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MkdirRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MkdirRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MkdirRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParentId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MkdirResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MkdirResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MkdirResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmdirRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmdirRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmdirRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParentId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmdirResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmdirResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmdirResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DirectoryId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatBlobServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatBlobServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatBlobServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthController
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthController
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityBytes", wireType)
			}
			m.CapacityBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapacityBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatBlobServerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowController
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatBlobServerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatBlobServerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskId", wireType)
			}
			m.DiskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowController
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipController(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthController
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipController(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowController
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowController
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowController
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthController
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupController
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthController
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthController        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowController          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupController = fmt.Errorf("proto: unexpected end of group")
)
