// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: basaltpb/blob.proto

package basaltpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BlobCreateRequest struct {
	Id                   UUID     `protobuf:"bytes,1,opt,name=id,proto3,customtype=UUID" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobCreateRequest) Reset()         { *m = BlobCreateRequest{} }
func (m *BlobCreateRequest) String() string { return proto.CompactTextString(m) }
func (*BlobCreateRequest) ProtoMessage()    {}
func (*BlobCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{0}
}
func (m *BlobCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobCreateRequest.Merge(m, src)
}
func (m *BlobCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobCreateRequest proto.InternalMessageInfo

type BlobCreateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobCreateResponse) Reset()         { *m = BlobCreateResponse{} }
func (m *BlobCreateResponse) String() string { return proto.CompactTextString(m) }
func (*BlobCreateResponse) ProtoMessage()    {}
func (*BlobCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{1}
}
func (m *BlobCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobCreateResponse.Merge(m, src)
}
func (m *BlobCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobCreateResponse proto.InternalMessageInfo

type BlobSealRequest struct {
	Id                   UUID     `protobuf:"bytes,1,opt,name=id,proto3,customtype=UUID" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobSealRequest) Reset()         { *m = BlobSealRequest{} }
func (m *BlobSealRequest) String() string { return proto.CompactTextString(m) }
func (*BlobSealRequest) ProtoMessage()    {}
func (*BlobSealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{2}
}
func (m *BlobSealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobSealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobSealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobSealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobSealRequest.Merge(m, src)
}
func (m *BlobSealRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobSealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobSealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobSealRequest proto.InternalMessageInfo

type BlobSealResponse struct {
	// Final size of the sealed object.
	FinalSize            int64    `protobuf:"varint,1,opt,name=final_size,json=finalSize,proto3" json:"final_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobSealResponse) Reset()         { *m = BlobSealResponse{} }
func (m *BlobSealResponse) String() string { return proto.CompactTextString(m) }
func (*BlobSealResponse) ProtoMessage()    {}
func (*BlobSealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{3}
}
func (m *BlobSealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobSealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobSealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobSealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobSealResponse.Merge(m, src)
}
func (m *BlobSealResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobSealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobSealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobSealResponse proto.InternalMessageInfo

func (m *BlobSealResponse) GetFinalSize() int64 {
	if m != nil {
		return m.FinalSize
	}
	return 0
}

type BlobDeleteRequest struct {
	Id                   UUID     `protobuf:"bytes,1,opt,name=id,proto3,customtype=UUID" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobDeleteRequest) Reset()         { *m = BlobDeleteRequest{} }
func (m *BlobDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*BlobDeleteRequest) ProtoMessage()    {}
func (*BlobDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{4}
}
func (m *BlobDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobDeleteRequest.Merge(m, src)
}
func (m *BlobDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobDeleteRequest proto.InternalMessageInfo

type BlobDeleteResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobDeleteResponse) Reset()         { *m = BlobDeleteResponse{} }
func (m *BlobDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*BlobDeleteResponse) ProtoMessage()    {}
func (*BlobDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{5}
}
func (m *BlobDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobDeleteResponse.Merge(m, src)
}
func (m *BlobDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobDeleteResponse proto.InternalMessageInfo

type BlobStatRequest struct {
	Id                   UUID     `protobuf:"bytes,1,opt,name=id,proto3,customtype=UUID" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobStatRequest) Reset()         { *m = BlobStatRequest{} }
func (m *BlobStatRequest) String() string { return proto.CompactTextString(m) }
func (*BlobStatRequest) ProtoMessage()    {}
func (*BlobStatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{6}
}
func (m *BlobStatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobStatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobStatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobStatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobStatRequest.Merge(m, src)
}
func (m *BlobStatRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobStatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobStatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobStatRequest proto.InternalMessageInfo

type BlobStatResponse struct {
	// Current size of the object.
	Size_ int64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// Whether the object is sealed.
	Sealed               bool     `protobuf:"varint,2,opt,name=sealed,proto3" json:"sealed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobStatResponse) Reset()         { *m = BlobStatResponse{} }
func (m *BlobStatResponse) String() string { return proto.CompactTextString(m) }
func (*BlobStatResponse) ProtoMessage()    {}
func (*BlobStatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{7}
}
func (m *BlobStatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobStatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobStatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobStatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobStatResponse.Merge(m, src)
}
func (m *BlobStatResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobStatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobStatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobStatResponse proto.InternalMessageInfo

func (m *BlobStatResponse) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *BlobStatResponse) GetSealed() bool {
	if m != nil {
		return m.Sealed
	}
	return false
}

type BlobCopyToRequest struct {
	// Object ID to upload from local storage.
	Id UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=UUID" json:"id"`
	// Destination URL in object storage:
	// - "s3://bucket/object-id"
	// - "gcs://bucket/object-id"
	// - "azure://container/object-id"
	Destination          string   `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobCopyToRequest) Reset()         { *m = BlobCopyToRequest{} }
func (m *BlobCopyToRequest) String() string { return proto.CompactTextString(m) }
func (*BlobCopyToRequest) ProtoMessage()    {}
func (*BlobCopyToRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{8}
}
func (m *BlobCopyToRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobCopyToRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobCopyToRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobCopyToRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobCopyToRequest.Merge(m, src)
}
func (m *BlobCopyToRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobCopyToRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobCopyToRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobCopyToRequest proto.InternalMessageInfo

func (m *BlobCopyToRequest) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type BlobCopyToResponse struct {
	// Archive reference URL with integrity check.
	// For S3: "s3://bucket/object-id?etag=xxx"
	// For GCS: "gcs://bucket/object-id#generation=xxx"
	ArchiveRef string `protobuf:"bytes,1,opt,name=archive_ref,json=archiveRef,proto3" json:"archive_ref,omitempty"`
	// Size of the uploaded object in bytes.
	Size_                int64    `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobCopyToResponse) Reset()         { *m = BlobCopyToResponse{} }
func (m *BlobCopyToResponse) String() string { return proto.CompactTextString(m) }
func (*BlobCopyToResponse) ProtoMessage()    {}
func (*BlobCopyToResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{9}
}
func (m *BlobCopyToResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobCopyToResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobCopyToResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobCopyToResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobCopyToResponse.Merge(m, src)
}
func (m *BlobCopyToResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobCopyToResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobCopyToResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobCopyToResponse proto.InternalMessageInfo

func (m *BlobCopyToResponse) GetArchiveRef() string {
	if m != nil {
		return m.ArchiveRef
	}
	return ""
}

func (m *BlobCopyToResponse) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type BlobCopyFromRequest struct {
	// Target object ID for local storage.
	Id UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=UUID" json:"id"`
	// Fully self-describing source URL:
	// - "s3://bucket/object-id?etag=xxx" (S3 with integrity check)
	// - "gcs://bucket/object-id" (GCS)
	// - "azure://container/object-id" (Azure Blob)
	// - "blob://host:port/object-id" (another blob server)
	Source               string   `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobCopyFromRequest) Reset()         { *m = BlobCopyFromRequest{} }
func (m *BlobCopyFromRequest) String() string { return proto.CompactTextString(m) }
func (*BlobCopyFromRequest) ProtoMessage()    {}
func (*BlobCopyFromRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{10}
}
func (m *BlobCopyFromRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobCopyFromRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobCopyFromRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobCopyFromRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobCopyFromRequest.Merge(m, src)
}
func (m *BlobCopyFromRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobCopyFromRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobCopyFromRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobCopyFromRequest proto.InternalMessageInfo

func (m *BlobCopyFromRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type BlobCopyFromResponse struct {
	// Size of the copied object in bytes.
	Size_                int64    `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobCopyFromResponse) Reset()         { *m = BlobCopyFromResponse{} }
func (m *BlobCopyFromResponse) String() string { return proto.CompactTextString(m) }
func (*BlobCopyFromResponse) ProtoMessage()    {}
func (*BlobCopyFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae28bb367c31dad4, []int{11}
}
func (m *BlobCopyFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobCopyFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobCopyFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobCopyFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobCopyFromResponse.Merge(m, src)
}
func (m *BlobCopyFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobCopyFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobCopyFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobCopyFromResponse proto.InternalMessageInfo

func (m *BlobCopyFromResponse) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func init() {
	proto.RegisterType((*BlobCreateRequest)(nil), "basaltpb.BlobCreateRequest")
	proto.RegisterType((*BlobCreateResponse)(nil), "basaltpb.BlobCreateResponse")
	proto.RegisterType((*BlobSealRequest)(nil), "basaltpb.BlobSealRequest")
	proto.RegisterType((*BlobSealResponse)(nil), "basaltpb.BlobSealResponse")
	proto.RegisterType((*BlobDeleteRequest)(nil), "basaltpb.BlobDeleteRequest")
	proto.RegisterType((*BlobDeleteResponse)(nil), "basaltpb.BlobDeleteResponse")
	proto.RegisterType((*BlobStatRequest)(nil), "basaltpb.BlobStatRequest")
	proto.RegisterType((*BlobStatResponse)(nil), "basaltpb.BlobStatResponse")
	proto.RegisterType((*BlobCopyToRequest)(nil), "basaltpb.BlobCopyToRequest")
	proto.RegisterType((*BlobCopyToResponse)(nil), "basaltpb.BlobCopyToResponse")
	proto.RegisterType((*BlobCopyFromRequest)(nil), "basaltpb.BlobCopyFromRequest")
	proto.RegisterType((*BlobCopyFromResponse)(nil), "basaltpb.BlobCopyFromResponse")
}

func init() { proto.RegisterFile("basaltpb/blob.proto", fileDescriptor_ae28bb367c31dad4) }

var fileDescriptor_ae28bb367c31dad4 = []byte{
	// 471 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x41, 0x6f, 0xd3, 0x30,
	0x14, 0xc7, 0x49, 0x57, 0x55, 0xed, 0xdb, 0x24, 0xc0, 0xab, 0xd0, 0x08, 0x5b, 0x5a, 0xe5, 0x34,
	0x21, 0x94, 0x68, 0x70, 0x43, 0x82, 0x43, 0x3b, 0x21, 0x55, 0xdc, 0x52, 0x76, 0xe1, 0x32, 0xd9,
	0xc9, 0x6b, 0x6b, 0xe1, 0xc5, 0x21, 0x71, 0x91, 0xd8, 0x87, 0xe1, 0xf3, 0xec, 0xc8, 0x99, 0xc3,
	0x84, 0xfa, 0x49, 0x50, 0x1c, 0x87, 0x26, 0xcd, 0x2a, 0x65, 0x37, 0xfb, 0x3d, 0xbf, 0xbf, 0x7f,
	0xf9, 0xfb, 0xaf, 0xc0, 0x31, 0xa3, 0x19, 0x15, 0x2a, 0x61, 0x3e, 0x13, 0x92, 0x79, 0x49, 0x2a,
	0x95, 0x24, 0xfd, 0xb2, 0x68, 0x0f, 0x97, 0x72, 0x29, 0x75, 0xd1, 0xcf, 0x57, 0x45, 0xdf, 0xbd,
	0x80, 0xe7, 0x13, 0x21, 0xd9, 0x34, 0x45, 0xaa, 0x30, 0xc0, 0xef, 0x6b, 0xcc, 0x14, 0x39, 0x85,
	0x0e, 0x8f, 0x4e, 0xac, 0xb1, 0x75, 0x7e, 0x34, 0x39, 0xba, 0xbb, 0x1f, 0x3d, 0xf9, 0x73, 0x3f,
	0xea, 0x5e, 0x5d, 0xcd, 0x2e, 0x83, 0x0e, 0x8f, 0xdc, 0x21, 0x90, 0xea, 0x48, 0x96, 0xc8, 0x38,
	0x43, 0xd7, 0x87, 0xa7, 0x79, 0x75, 0x8e, 0x54, 0xb4, 0x93, 0xb9, 0x80, 0x67, 0xdb, 0x81, 0x42,
	0x84, 0x9c, 0x01, 0x2c, 0x78, 0x4c, 0xc5, 0x75, 0xc6, 0x6f, 0x51, 0x4f, 0x1e, 0x04, 0x03, 0x5d,
	0x99, 0xf3, 0x5b, 0x2c, 0x61, 0x2f, 0x51, 0xe0, 0x23, 0x61, 0xcb, 0x91, 0x1d, 0x58, 0x45, 0x55,
	0x3b, 0x99, 0x8f, 0x06, 0x56, 0x0f, 0x18, 0x58, 0x02, 0xdd, 0x0a, 0xa6, 0x5e, 0x93, 0x17, 0xd0,
	0xcb, 0x90, 0x0a, 0x8c, 0x4e, 0x3a, 0x63, 0xeb, 0xbc, 0x1f, 0x98, 0x9d, 0x3b, 0x37, 0x36, 0xcb,
	0xe4, 0xe7, 0x17, 0xd9, 0xea, 0x4a, 0x32, 0x86, 0xc3, 0x08, 0x33, 0xc5, 0x63, 0xaa, 0xb8, 0x8c,
	0xb5, 0xde, 0x20, 0xa8, 0x96, 0xdc, 0x99, 0x79, 0x08, 0x23, 0x6a, 0xb0, 0x46, 0x70, 0x48, 0xd3,
	0x70, 0xc5, 0x7f, 0xe0, 0x75, 0x8a, 0x0b, 0x2d, 0x3f, 0x08, 0xc0, 0x94, 0x02, 0x5c, 0xfc, 0xe7,
	0xee, 0x6c, 0xb9, 0xdd, 0xcf, 0x70, 0x5c, 0x4a, 0x7d, 0x4a, 0xe5, 0x4d, 0x3b, 0xc2, 0xfc, 0x63,
	0xe5, 0x3a, 0x0d, 0xd1, 0xc0, 0x99, 0x9d, 0xfb, 0x1a, 0x86, 0x75, 0xb1, 0xfd, 0x86, 0xbd, 0xfd,
	0x75, 0x00, 0xdd, 0xfc, 0x30, 0x99, 0x42, 0xaf, 0x48, 0x14, 0x79, 0xe5, 0x95, 0x99, 0xf5, 0x1a,
	0xd1, 0xb4, 0x4f, 0x1f, 0x6e, 0x9a, 0x1b, 0x3e, 0x40, 0x37, 0xcf, 0x13, 0x79, 0x59, 0x3f, 0x55,
	0x09, 0xa5, 0x6d, 0x3f, 0xd4, 0x32, 0xe3, 0x53, 0xe8, 0x15, 0x41, 0xd9, 0x65, 0xa8, 0x25, 0x6e,
	0x97, 0xa1, 0x9e, 0x2d, 0xcd, 0xa0, 0xa8, 0x6a, 0x30, 0x6c, 0xb3, 0xd6, 0x60, 0xa8, 0xa6, 0x2a,
	0xf7, 0x41, 0x3f, 0x68, 0xc3, 0x87, 0x6a, 0x76, 0x1a, 0x3e, 0xd4, 0x33, 0x30, 0x83, 0x7e, 0xe9,
	0x3e, 0x39, 0x6b, 0x9e, 0xac, 0x3c, 0xb1, 0xed, 0xec, 0x6b, 0x17, 0x52, 0x93, 0xf7, 0x77, 0x1b,
	0xc7, 0xfa, 0xbd, 0x71, 0xac, 0xbf, 0x1b, 0xc7, 0xfa, 0xfa, 0x66, 0xc9, 0xd5, 0x6a, 0xcd, 0xbc,
	0x50, 0xde, 0xf8, 0xa1, 0x0c, 0xbf, 0xa5, 0x92, 0x86, 0xab, 0x88, 0xf9, 0x85, 0x46, 0x28, 0x38,
	0xc6, 0xca, 0x2f, 0x05, 0x59, 0x4f, 0xff, 0x63, 0xde, 0xfd, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x9f,
	0x91, 0xf8, 0xa9, 0x9a, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BlobClient is the client API for Blob service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BlobClient interface {
	// Create initializes a new object on this blob server.
	Create(ctx context.Context, in *BlobCreateRequest, opts ...grpc.CallOption) (*BlobCreateResponse, error)
	// Seal marks an object as immutable on this replica.
	Seal(ctx context.Context, in *BlobSealRequest, opts ...grpc.CallOption) (*BlobSealResponse, error)
	// Delete removes an object from this blob server.
	Delete(ctx context.Context, in *BlobDeleteRequest, opts ...grpc.CallOption) (*BlobDeleteResponse, error)
	// Stat returns metadata about an object.
	Stat(ctx context.Context, in *BlobStatRequest, opts ...grpc.CallOption) (*BlobStatResponse, error)
	// CopyTo uploads a local object to object storage.
	// Used after SSTable creation to archive to S3/GCS/Azure for cross-AZ
	// replication and continuous backup.
	//
	// Destination URL format: "s3://bucket/object-id", "gcs://bucket/object-id"
	//
	// The blob server uploads directly to object storage and returns an
	// archive_ref with integrity check (etag for S3).
	CopyTo(ctx context.Context, in *BlobCopyToRequest, opts ...grpc.CallOption) (*BlobCopyToResponse, error)
	// CopyFrom copies an object from a source URL to this blob server.
	// Used for cross-AZ materialization (from object storage) and repair
	// (from object storage or another blob server).
	//
	// Source URL formats:
	// - Object storage: "s3://bucket/object-id?etag=xxx", "gcs://bucket/object-id"
	// - Blob server: "blob://host:port/object-id"
	//
	// The blob server downloads from the source, verifies integrity (etag for S3),
	// and stores locally with the specified object ID.
	CopyFrom(ctx context.Context, in *BlobCopyFromRequest, opts ...grpc.CallOption) (*BlobCopyFromResponse, error)
}

type blobClient struct {
	cc *grpc.ClientConn
}

func NewBlobClient(cc *grpc.ClientConn) BlobClient {
	return &blobClient{cc}
}

func (c *blobClient) Create(ctx context.Context, in *BlobCreateRequest, opts ...grpc.CallOption) (*BlobCreateResponse, error) {
	out := new(BlobCreateResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Blob/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobClient) Seal(ctx context.Context, in *BlobSealRequest, opts ...grpc.CallOption) (*BlobSealResponse, error) {
	out := new(BlobSealResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Blob/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobClient) Delete(ctx context.Context, in *BlobDeleteRequest, opts ...grpc.CallOption) (*BlobDeleteResponse, error) {
	out := new(BlobDeleteResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Blob/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobClient) Stat(ctx context.Context, in *BlobStatRequest, opts ...grpc.CallOption) (*BlobStatResponse, error) {
	out := new(BlobStatResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Blob/Stat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobClient) CopyTo(ctx context.Context, in *BlobCopyToRequest, opts ...grpc.CallOption) (*BlobCopyToResponse, error) {
	out := new(BlobCopyToResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Blob/CopyTo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobClient) CopyFrom(ctx context.Context, in *BlobCopyFromRequest, opts ...grpc.CallOption) (*BlobCopyFromResponse, error) {
	out := new(BlobCopyFromResponse)
	err := c.cc.Invoke(ctx, "/basaltpb.Blob/CopyFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlobServer is the server API for Blob service.
type BlobServer interface {
	// Create initializes a new object on this blob server.
	Create(context.Context, *BlobCreateRequest) (*BlobCreateResponse, error)
	// Seal marks an object as immutable on this replica.
	Seal(context.Context, *BlobSealRequest) (*BlobSealResponse, error)
	// Delete removes an object from this blob server.
	Delete(context.Context, *BlobDeleteRequest) (*BlobDeleteResponse, error)
	// Stat returns metadata about an object.
	Stat(context.Context, *BlobStatRequest) (*BlobStatResponse, error)
	// CopyTo uploads a local object to object storage.
	// Used after SSTable creation to archive to S3/GCS/Azure for cross-AZ
	// replication and continuous backup.
	//
	// Destination URL format: "s3://bucket/object-id", "gcs://bucket/object-id"
	//
	// The blob server uploads directly to object storage and returns an
	// archive_ref with integrity check (etag for S3).
	CopyTo(context.Context, *BlobCopyToRequest) (*BlobCopyToResponse, error)
	// CopyFrom copies an object from a source URL to this blob server.
	// Used for cross-AZ materialization (from object storage) and repair
	// (from object storage or another blob server).
	//
	// Source URL formats:
	// - Object storage: "s3://bucket/object-id?etag=xxx", "gcs://bucket/object-id"
	// - Blob server: "blob://host:port/object-id"
	//
	// The blob server downloads from the source, verifies integrity (etag for S3),
	// and stores locally with the specified object ID.
	CopyFrom(context.Context, *BlobCopyFromRequest) (*BlobCopyFromResponse, error)
}

// UnimplementedBlobServer can be embedded to have forward compatible implementations.
type UnimplementedBlobServer struct {
}

func (*UnimplementedBlobServer) Create(ctx context.Context, req *BlobCreateRequest) (*BlobCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedBlobServer) Seal(ctx context.Context, req *BlobSealRequest) (*BlobSealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (*UnimplementedBlobServer) Delete(ctx context.Context, req *BlobDeleteRequest) (*BlobDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedBlobServer) Stat(ctx context.Context, req *BlobStatRequest) (*BlobStatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stat not implemented")
}
func (*UnimplementedBlobServer) CopyTo(ctx context.Context, req *BlobCopyToRequest) (*BlobCopyToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyTo not implemented")
}
func (*UnimplementedBlobServer) CopyFrom(ctx context.Context, req *BlobCopyFromRequest) (*BlobCopyFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyFrom not implemented")
}

func RegisterBlobServer(s *grpc.Server, srv BlobServer) {
	s.RegisterService(&_Blob_serviceDesc, srv)
}

func _Blob_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Blob/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobServer).Create(ctx, req.(*BlobCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blob_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobSealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Blob/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobServer).Seal(ctx, req.(*BlobSealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blob_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Blob/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobServer).Delete(ctx, req.(*BlobDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blob_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobStatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Blob/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobServer).Stat(ctx, req.(*BlobStatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blob_CopyTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobCopyToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobServer).CopyTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Blob/CopyTo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobServer).CopyTo(ctx, req.(*BlobCopyToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blob_CopyFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobCopyFromRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobServer).CopyFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/basaltpb.Blob/CopyFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobServer).CopyFrom(ctx, req.(*BlobCopyFromRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Blob_serviceDesc = grpc.ServiceDesc{
	ServiceName: "basaltpb.Blob",
	HandlerType: (*BlobServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Blob_Create_Handler,
		},
		{
			MethodName: "Seal",
			Handler:    _Blob_Seal_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Blob_Delete_Handler,
		},
		{
			MethodName: "Stat",
			Handler:    _Blob_Stat_Handler,
		},
		{
			MethodName: "CopyTo",
			Handler:    _Blob_CopyTo_Handler,
		},
		{
			MethodName: "CopyFrom",
			Handler:    _Blob_CopyFrom_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "basaltpb/blob.proto",
}

func (m *BlobCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBlob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlobCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BlobSealRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobSealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobSealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBlob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlobSealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobSealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobSealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FinalSize != 0 {
		i = encodeVarintBlob(dAtA, i, uint64(m.FinalSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlobDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBlob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlobDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BlobStatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobStatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobStatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBlob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlobStatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobStatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobStatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sealed {
		i--
		if m.Sealed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintBlob(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlobCopyToRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobCopyToRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobCopyToRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintBlob(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBlob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlobCopyToResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobCopyToResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobCopyToResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintBlob(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ArchiveRef) > 0 {
		i -= len(m.ArchiveRef)
		copy(dAtA[i:], m.ArchiveRef)
		i = encodeVarintBlob(dAtA, i, uint64(len(m.ArchiveRef)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlobCopyFromRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobCopyFromRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobCopyFromRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintBlob(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBlob(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlobCopyFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobCopyFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobCopyFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintBlob(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBlob(dAtA []byte, offset int, v uint64) int {
	offset -= sovBlob(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BlobCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovBlob(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobSealRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovBlob(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobSealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FinalSize != 0 {
		n += 1 + sovBlob(uint64(m.FinalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovBlob(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobStatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovBlob(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobStatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovBlob(uint64(m.Size_))
	}
	if m.Sealed {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobCopyToRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovBlob(uint64(l))
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovBlob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobCopyToResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ArchiveRef)
	if l > 0 {
		n += 1 + l + sovBlob(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBlob(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobCopyFromRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovBlob(uint64(l))
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovBlob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobCopyFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovBlob(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBlob(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBlob(x uint64) (n int) {
	return sovBlob(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BlobCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobSealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobSealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobSealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobSealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobSealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobSealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalSize", wireType)
			}
			m.FinalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobStatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobStatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobStatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobStatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobStatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobStatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sealed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sealed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobCopyToRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobCopyToRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobCopyToRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobCopyToResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobCopyToResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobCopyToResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchiveRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobCopyFromRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobCopyFromRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobCopyFromRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobCopyFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobCopyFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobCopyFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBlob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBlob(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBlob
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBlob
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBlob
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBlob
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBlob        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBlob          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBlob = fmt.Errorf("proto: unexpected end of group")
)
